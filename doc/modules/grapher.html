<!DOCTYPE html><html lang="en"><head><title>modules/grapher</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../"><meta name="groc-document-path" content="modules/grapher"><meta name="groc-project-path" content="modules/grapher.js"><link rel="stylesheet" type="text/css" media="all" href="../assets/style.css"><script type="text/javascript" src="../assets/behavior.js"></script><body><div id="meta"><div class="file-path">modules/grapher.js</div></div><div id="document"><div class="segment"><div class="comments "><div class="wrapper"><p>Ayasdi Inc. Copyright 2014
Grapher.js may be freely distributed under the Apache 2.0 license</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Grapher: WebGL network graph rendering with PIXI</p></div></div><div class="code"><div class="wrapper"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Grapher</span> <span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">this</span>.initialize.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Helpers</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> PIXI = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./vendor/pixi.js'</span>),
    _ = <span class="hljs-built_in">require</span>(<span class="hljs-string">'jashkenas/underscore@1.6.0'</span>),
    Color = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./color.js'</span>),
    pixelRes = <span class="hljs-keyword">typeof</span> devicePixelRatio !== <span class="hljs-string">'undefined'</span> ? devicePixelRatio : <span class="hljs-number">1</span>,
    noop = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{};

PIXI.dontSayHello = <span class="hljs-literal">true</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Static</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> NODES = Grapher.NODES = <span class="hljs-string">'nodes'</span>;
<span class="hljs-keyword">var</span> LINKS = Grapher.LINKS = <span class="hljs-string">'links'</span>;
Grapher.palettes = {}; <span class="hljs-comment">// store palettes and textures staticly</span>
Grapher.textures = {};
Grapher.textures[NODES] = {};
Grapher.textures[LINKS] = {};

Grapher.getPalette = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(name)</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.palettes[name]; };

Grapher.setPalette = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(name, swatches)</span> </span>{
  <span class="hljs-keyword">var</span> palette = <span class="hljs-keyword">this</span>.palettes[name] = {};
  swatches = _.map(swatches, Color.parse);

  _.each(swatches, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(swatch, i)</span> </span>{
    <span class="hljs-keyword">this</span>.getTexture(LINKS, swatch);
    <span class="hljs-keyword">this</span>.getTexture(NODES, swatch);
    palette[i] = swatch;

    <span class="hljs-keyword">var</span> j;
    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; i; j++) { <span class="hljs-comment">// interpolate 'in-between' link colors 50% between node colors</span>
      <span class="hljs-keyword">var</span> color = Color.interpolate(swatches[j], swatch, <span class="hljs-number">0.5</span>);
      <span class="hljs-keyword">this</span>.getTexture(LINKS, color);
      palette[j + <span class="hljs-string">'-'</span> + i] = color;
    }
  }.bind(<span class="hljs-keyword">this</span>));
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
};

Grapher.getTexture = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(type, color)</span> </span>{
  <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.textures[type][color]) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>generate the textures from Canvas</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">var</span> isNode = type === NODES,
        size = isNode ? <span class="hljs-number">100</span> : <span class="hljs-number">1</span>,
        renderer = <span class="hljs-keyword">new</span> PIXI.CanvasRenderer(size, size, {transparent: isNode, resolution: pixelRes}),
        stage = <span class="hljs-keyword">new</span> PIXI.Stage(color);

    <span class="hljs-keyword">if</span> (isNode) {
      graphics = <span class="hljs-keyword">new</span> PIXI.Graphics();
      graphics.beginFill(color);
      graphics.drawCircle(size / <span class="hljs-number">2</span>, size / <span class="hljs-number">2</span>, size / <span class="hljs-number">2</span>);
      graphics.endFill();

      stage.addChild(graphics);
    }

    renderer.render(stage);

    <span class="hljs-keyword">this</span>.textures[type][color] = <span class="hljs-keyword">new</span> PIXI.Texture.fromCanvas(renderer.view);
  }
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.textures[type][color];
};</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Grapher instances</p></div></div><div class="code"><div class="wrapper">Grapher.prototype = {
  _lineWidth: <span class="hljs-number">2</span>,
  _foregroundColor: <span class="hljs-number">0x222222</span>,
  _backgroundColor: <span class="hljs-number">0xffffff</span>,

  initialize: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(width, height, o)</span> </span>{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Extend default options</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">var</span> options = _.extend({
      antialias: <span class="hljs-literal">true</span>,
      resolution: pixelRes
    }, o);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Renderer and view</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">this</span>.renderer = PIXI.autoDetectRenderer(width, height, options);
    <span class="hljs-keyword">this</span>.view = <span class="hljs-keyword">this</span>.renderer.view;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Stage and containers</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">this</span>.stage = <span class="hljs-keyword">new</span> PIXI.Stage(<span class="hljs-keyword">this</span>.backgroundColor());
    <span class="hljs-keyword">this</span>.network = <span class="hljs-keyword">new</span> PIXI.DisplayObjectContainer();
    <span class="hljs-keyword">this</span>.stage.addChild(<span class="hljs-keyword">this</span>.network);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>SpriteBatch containers</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">this</span>.batches = {};
    <span class="hljs-keyword">this</span>.batches[NODES] = {};
    <span class="hljs-keyword">this</span>.batches[LINKS] = {};</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Sprite array</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">this</span>[LINKS] = [];
    <span class="hljs-keyword">this</span>[NODES] = [];</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>indices that will update</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">this</span>.willUpdate = {};
    <span class="hljs-keyword">this</span>.updateAll = {};
    <span class="hljs-keyword">this</span>._clearUpdateQueue();</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Listeners</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">this</span>.listeners = {};</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Set initial transform</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">this</span>.center();</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Bind some updaters</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">this</span>._updateLink = <span class="hljs-keyword">this</span>._updateLink.bind(<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">this</span>._updateNode = <span class="hljs-keyword">this</span>._updateNode.bind(<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">this</span>.animate = <span class="hljs-keyword">this</span>.animate.bind(<span class="hljs-keyword">this</span>);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Interactions</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">this</span>.stage.interactive = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">this</span>.stage.mousedown = <span class="hljs-keyword">this</span>._onEvent(<span class="hljs-string">'mousedown'</span>);
    <span class="hljs-keyword">this</span>.stage.mousemove = <span class="hljs-keyword">this</span>._onEvent(<span class="hljs-string">'mousemove'</span>);
    <span class="hljs-keyword">this</span>.stage.mouseup = <span class="hljs-keyword">this</span>._onEvent(<span class="hljs-string">'mouseup'</span>);
  },</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>ex. grapher.on(&#39;mousedown&#39;, function () {...});</p></div></div><div class="code"><div class="wrapper">  on: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(event, fn)</span> </span>{
    <span class="hljs-keyword">if</span> (_.isFunction(fn)) <span class="hljs-keyword">this</span>.listeners[event] = fn;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  },

  off: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(event)</span> </span>{
    <span class="hljs-keyword">if</span> (event <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>.listeners) <span class="hljs-keyword">this</span>.listeners[event] = noop;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  },

  palette: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(name)</span> </span>{
    <span class="hljs-keyword">if</span> (_.isUndefined(name)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._palette;

    <span class="hljs-keyword">this</span>._palette = Grapher.getPalette(name);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  },</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Accepts network data in the form:
{
  nodes: [{x: 0, y: 0, r: 20, color: (swatch or hex/rgb)}, ... ].
  links: [{from: 0, to: 1, color: (swatch or hex/rgb)}, ... ]</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-comment">// </span>
  data: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(data)</span> </span>{
    <span class="hljs-keyword">if</span> (_.isUndefined(data)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._data;

    <span class="hljs-keyword">this</span>._data = data;
    <span class="hljs-keyword">this</span>.exit();
    <span class="hljs-keyword">this</span>.enter();
    <span class="hljs-keyword">this</span>.update();
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  },

  enter: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">var</span> data = <span class="hljs-keyword">this</span>.data(),
        entering = [];

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>[LINKS].length &lt; data[LINKS].length)
        entering = entering.concat(data[LINKS].slice(<span class="hljs-keyword">this</span>[LINKS].length, data[LINKS].length - <span class="hljs-keyword">this</span>[LINKS].length));
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>[NODES].length &lt; data[NODES].length)
        entering = entering.concat(data[NODES].slice(<span class="hljs-keyword">this</span>[NODES].length, data[NODES].length - <span class="hljs-keyword">this</span>[NODES].length));

    _.each(entering, <span class="hljs-keyword">this</span>._enter.bind(<span class="hljs-keyword">this</span>));
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  },

  exit: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">var</span> data = <span class="hljs-keyword">this</span>.data(),
        exiting = [];

    <span class="hljs-keyword">if</span> (data[LINKS].length &lt; <span class="hljs-keyword">this</span>[LINKS].length)
        exiting = exiting.concat(<span class="hljs-keyword">this</span>[LINKS].splice(data[LINKS].length, <span class="hljs-keyword">this</span>[LINKS].length - data[LINKS].length));
    <span class="hljs-keyword">if</span> (data[NODES].length &lt; <span class="hljs-keyword">this</span>[NODES].length)
        exiting = exiting.concat(<span class="hljs-keyword">this</span>[NODES].splice(data[NODES].length, <span class="hljs-keyword">this</span>[NODES].length - data[NODES].length));

    _.each(exiting, <span class="hljs-keyword">this</span>._exit.bind(<span class="hljs-keyword">this</span>));
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  },</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>ex.  grapher.update(); // updates all nodes and links
     grapher.update(&#39;links&#39;); // updates only links
     grapher.update(&#39;nodes&#39;, 0, 4); // updates nodes indices 0 to 3 (4 is not inclusive)
     grapher.update(&#39;links&#39;, [0, 1, 2, 6, 32]); // updates links indexed by the indices</p></div></div><div class="code"><div class="wrapper">  update: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(type, start, end)</span> </span>{
    <span class="hljs-keyword">var</span> indices;
    <span class="hljs-keyword">if</span> (_.isArray(start)) indices = start;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (_.isNumber(start) &amp;&amp; _.isNumber(end)) indices = _.range(start, end);

    <span class="hljs-keyword">if</span> (_.isArray(indices)) {
      <span class="hljs-keyword">this</span>._addToUpdateQueue(type, indices);
      <span class="hljs-keyword">if</span> (type === NODES) <span class="hljs-keyword">this</span>._addToUpdateQueue(LINKS, <span class="hljs-keyword">this</span>._findLinks(indices));
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">this</span>.updateAll[LINKS] = <span class="hljs-keyword">this</span>.updateAll[LINKS] || type !== NODES;
      <span class="hljs-keyword">this</span>.updateAll[NODES] = <span class="hljs-keyword">this</span>.updateAll[NODES] || type !== LINKS;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  },</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Update an individual node by index.</p></div></div><div class="code"><div class="wrapper">  updateNode: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(index, willUpdateLinks)</span> </span>{
    <span class="hljs-keyword">this</span>._addToUpdateQueue(NODES, [index]);
    <span class="hljs-keyword">if</span> (willUpdateLinks) <span class="hljs-keyword">this</span>._addToUpdateQueue(LINKS, <span class="hljs-keyword">this</span>._findLinks([index]));
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  },</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Update an individual link by index.</p></div></div><div class="code"><div class="wrapper">  updateLink: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(index)</span> </span>{
    <span class="hljs-keyword">this</span>._addToUpdateQueue(LINKS, [index]);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  },

  render: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">this</span>._update();
    <span class="hljs-keyword">this</span>.renderer.render(<span class="hljs-keyword">this</span>.stage);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  },

  animate: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(time)</span> </span>{
    <span class="hljs-keyword">this</span>.render();
    <span class="hljs-keyword">this</span>._frame = requestAnimationFrame(<span class="hljs-keyword">this</span>.animate);
  },

  play: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    requestAnimationFrame(<span class="hljs-keyword">this</span>.animate);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  },

  pause: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._frame) cancelAnimationFrame(<span class="hljs-keyword">this</span>._frame);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  },

  resize: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(width, height)</span> </span>{
    <span class="hljs-keyword">this</span>.renderer.resize(width, height);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  },

  center: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">var</span> x = y = <span class="hljs-number">0</span>,
        scale = <span class="hljs-number">1</span>,
        nodes = <span class="hljs-keyword">this</span>.data() ? <span class="hljs-keyword">this</span>.data()[NODES] : <span class="hljs-literal">null</span>,
        numNodes = nodes ? nodes.length : <span class="hljs-number">0</span>;

    <span class="hljs-keyword">if</span> (numNodes) { <span class="hljs-comment">// get initial transform</span>
      <span class="hljs-keyword">var</span> minX = <span class="hljs-literal">Infinity</span>, maxX = -<span class="hljs-literal">Infinity</span>,
          minY = <span class="hljs-literal">Infinity</span>, maxY = -<span class="hljs-literal">Infinity</span>,
          width = <span class="hljs-keyword">this</span>.renderer.width / <span class="hljs-keyword">this</span>.renderer.resolution,
          height = <span class="hljs-keyword">this</span>.renderer.height / <span class="hljs-keyword">this</span>.renderer.resolution,
          pad = <span class="hljs-number">1.1</span>,
          i;

      <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; numNodes; i++) {
        <span class="hljs-keyword">if</span> (nodes[i].x &lt; minX) minX = nodes[i].x;
        <span class="hljs-keyword">if</span> (nodes[i].x &gt; maxX) maxX = nodes[i].x;
        <span class="hljs-keyword">if</span> (nodes[i].y &lt; minY) minY = nodes[i].y;
        <span class="hljs-keyword">if</span> (nodes[i].y &gt; maxY) maxY = nodes[i].y;
      }
      
      <span class="hljs-keyword">var</span> dX = maxX - minX,
          dY = maxY - minY;

      scale = <span class="hljs-built_in">Math</span>.min(width / dX, height / dY, <span class="hljs-number">2</span>) / pad;
      x = (width - dX * scale) / <span class="hljs-number">2</span> - minX * scale;
      y = (height - dY * scale) / <span class="hljs-number">2</span> - minY * scale;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.transform({scale: scale, translate: [x, y]});
  },

  transform: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(transform)</span> </span>{
    <span class="hljs-keyword">if</span> (_.isUndefined(transform)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._transform;

    <span class="hljs-keyword">this</span>._transform = _.extend(<span class="hljs-keyword">this</span>._transform ? <span class="hljs-keyword">this</span>._transform : {}, transform);
    <span class="hljs-keyword">this</span>.updateTransform = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  },

  backgroundColor: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(color)</span> </span>{
    <span class="hljs-keyword">if</span> (_.isUndefined(color)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._backgroundColor;

    <span class="hljs-keyword">this</span>._backgroundColor = Color.parse(color);
    <span class="hljs-keyword">this</span>.stage.setBackgroundColor(<span class="hljs-keyword">this</span>._backgroundColor);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  },

  foregroundColor: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(color)</span> </span>{
    <span class="hljs-keyword">if</span> (_.isUndefined(color)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._foregroundColor;
    
    <span class="hljs-keyword">this</span>._foregroundColor = Color.parse(color);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  },

  lineWidth: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(size)</span> </span>{
    <span class="hljs-keyword">if</span> (_.isUndefined(size)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._lineWidth;
    
    <span class="hljs-keyword">this</span>._lineWidth = size;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  },

  getNodeIdAt: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(x, y)</span> </span>{
    <span class="hljs-keyword">var</span> node = -<span class="hljs-number">1</span>;

    <span class="hljs-keyword">this</span>[NODES].every(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(n, i)</span> </span>{ <span class="hljs-comment">// we'll want to look for ways to optimize this</span>
      <span class="hljs-keyword">var</span> inX = x &lt;= n.position.x + n.width &amp;&amp; x &gt;= n.position.x,
          inY = y &lt;= n.position.y + n.height &amp;&amp; y &gt;= n.position.y,
          found = inX &amp;&amp; inY;
      <span class="hljs-keyword">if</span> (found) node = i;
      <span class="hljs-keyword">return</span> !found;
    });

    <span class="hljs-keyword">return</span> node;
  },

  _exit: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(sprite)</span> </span>{ <span class="hljs-keyword">return</span> sprite.parent.removeChild(sprite); },
  _enter: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(data)</span> </span>{
    <span class="hljs-keyword">var</span> type = _.isUndefined(data.from) ? NODES : LINKS,
        sprite = <span class="hljs-keyword">new</span> PIXI.Sprite(Grapher.getTexture(type, <span class="hljs-keyword">this</span>.foregroundColor()));
    <span class="hljs-keyword">this</span>[type].push(sprite);
  },

  _addToUpdateQueue: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(type, indices)</span> </span>{
    <span class="hljs-keyword">var</span> insertIntoQueue = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(i)</span> </span>{
          <span class="hljs-keyword">var</span> atIndex = _.sortedIndex(<span class="hljs-keyword">this</span>.willUpdate[type], i);
          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.willUpdate[type][atIndex] !== i)
            <span class="hljs-keyword">this</span>.willUpdate[type].splice(atIndex, <span class="hljs-number">0</span>, i);
        }.bind(<span class="hljs-keyword">this</span>);

    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.updateAll[type] &amp;&amp; _.isArray(indices)) _.each(indices, insertIntoQueue);
    <span class="hljs-keyword">this</span>.updateAll[type] = <span class="hljs-keyword">this</span>.updateAll[type] || <span class="hljs-keyword">this</span>.willUpdate[type].length &gt;= <span class="hljs-keyword">this</span>[type].length;
  },

  _clearUpdateQueue: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">this</span>.willUpdate[LINKS] = [];
    <span class="hljs-keyword">this</span>.willUpdate[NODES] = [];
    <span class="hljs-keyword">this</span>.updateAll[LINKS] = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">this</span>.updateAll[NODES] = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">this</span>.updateTransform = <span class="hljs-literal">false</span>;
  },

  _update: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">var</span> updatingLinks = <span class="hljs-keyword">this</span>.willUpdate[LINKS],
        updatingNodes = <span class="hljs-keyword">this</span>.willUpdate[NODES],
        i;

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.updateAll[LINKS]) _.each(<span class="hljs-keyword">this</span>[LINKS], <span class="hljs-keyword">this</span>._updateLink);
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (updatingLinks &amp;&amp; updatingLinks.length) {
      <span class="hljs-keyword">while</span> (updatingLinks.length) {
        i = updatingLinks.shift();
        <span class="hljs-keyword">this</span>._updateLinkByIndex(i);
      }
    }

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.updateAll[NODES]) _.each(<span class="hljs-keyword">this</span>[NODES], <span class="hljs-keyword">this</span>._updateNode);
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (updatingNodes &amp;&amp; updatingNodes.length) {
      <span class="hljs-keyword">while</span> (updatingNodes.length) {
        i = updatingNodes.shift();
        <span class="hljs-keyword">this</span>._updateNodeByIndex(i);
      }
    }

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.updateTransform) {
      <span class="hljs-keyword">var</span> transform = <span class="hljs-keyword">this</span>.transform();
      <span class="hljs-keyword">this</span>.network.scale.set(transform.scale);
      <span class="hljs-keyword">this</span>.network.position.set.apply(<span class="hljs-keyword">this</span>.network, transform.translate);
    }

    <span class="hljs-keyword">this</span>._clearUpdateQueue();
  },

  _updateLink: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(link, i)</span> </span>{
    <span class="hljs-keyword">var</span> data = <span class="hljs-keyword">this</span>.data(),
        lw = <span class="hljs-keyword">this</span>.lineWidth(),
        l = data[LINKS][i],
        from = data[NODES][l.from],
        to = data[NODES][l.to],
        leftMost = from.x &lt;= to.x ? from : to;

    link.width = <span class="hljs-built_in">Math</span>.sqrt(<span class="hljs-built_in">Math</span>.pow(to.x - from.x, <span class="hljs-number">2</span>) + <span class="hljs-built_in">Math</span>.pow(to.y - from.y, <span class="hljs-number">2</span>));
    link.height = lw;
    link.position.set(leftMost.x, leftMost.y - lw / <span class="hljs-number">2</span>);
    link.pivot.set(<span class="hljs-number">0</span>, lw / <span class="hljs-number">2</span>);
    link.rotation = <span class="hljs-built_in">Math</span>.atan((to.y - from.y) / (to.x - from.x));

    <span class="hljs-keyword">var</span> color = !_.isUndefined(l.color) ? <span class="hljs-keyword">this</span>._findColor(l.color) :
        Color.interpolate(<span class="hljs-keyword">this</span>._findColor(from.color), <span class="hljs-keyword">this</span>._findColor(to.color));

    <span class="hljs-keyword">this</span>._setColor(LINKS, link, color);
  },

  _updateNode: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(node, i)</span> </span>{
    <span class="hljs-keyword">var</span> n = <span class="hljs-keyword">this</span>.data()[NODES][i];
    node.width = n.r * <span class="hljs-number">2</span>;
    node.height = n.r * <span class="hljs-number">2</span>;
    node.position.set(n.x - n.r, n.y - n.r);

    <span class="hljs-keyword">this</span>._setColor(NODES, node, <span class="hljs-keyword">this</span>._findColor(n.color));
  },

  _updateNodeByIndex: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(i)</span> </span>{ <span class="hljs-keyword">this</span>._updateNode(<span class="hljs-keyword">this</span>[NODES][i], i); },

  _updateLinkByIndex: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(i)</span> </span>{ <span class="hljs-keyword">this</span>._updateLink(<span class="hljs-keyword">this</span>[LINKS][i], i); },

  _findLinks: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(indices)</span> </span>{
    <span class="hljs-keyword">var</span> isLinked = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(indices, l)</span> </span>{
          <span class="hljs-keyword">var</span> i, len = indices.length, flag = <span class="hljs-literal">false</span>;
          <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++) {
            <span class="hljs-keyword">if</span> (l.to == indices[i] || l.from == indices[i]) { <span class="hljs-comment">// loose equivalience is sufficient</span>
              flag = <span class="hljs-literal">true</span>;
              <span class="hljs-keyword">break</span>;
            }
          }
          <span class="hljs-keyword">return</span> flag;
        },
        links = <span class="hljs-keyword">this</span>.data()[LINKS],
        i, numLinks = links.length,
        updatingLinks = [];

    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; numLinks; i++) {
      <span class="hljs-keyword">if</span> (isLinked(indices, links[i])) updatingLinks.push(i);
    }

    <span class="hljs-keyword">return</span> updatingLinks;
  },

  _findColor: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(c)</span> </span>{
    <span class="hljs-keyword">var</span> color = <span class="hljs-literal">NaN</span>,
        palette = <span class="hljs-keyword">this</span>.palette();

    <span class="hljs-keyword">if</span> (palette &amp;&amp; palette[c]) color = palette[c];
    <span class="hljs-keyword">else</span> color = Color.parse(c);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>if color is still not set, use the default</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> (_.isNaN(color)) color = <span class="hljs-keyword">this</span>.foregroundColor();
    <span class="hljs-keyword">return</span> color;
  },

  _setColor: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(type, sprite, color)</span> </span>{
    <span class="hljs-keyword">var</span> texture = Grapher.getTexture(type, color);

    sprite.setTexture(texture);
    <span class="hljs-keyword">if</span> (sprite.parent) <span class="hljs-keyword">this</span>._exit(sprite);
    <span class="hljs-keyword">this</span>._getBatch(type, color).addChild(sprite);
  },

  _getBatch: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(type, color)</span> </span>{
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.batches[type][color]) {
      <span class="hljs-keyword">var</span> batch = <span class="hljs-keyword">new</span> PIXI.SpriteBatch();
      <span class="hljs-keyword">if</span> (type === LINKS) <span class="hljs-keyword">this</span>.network.addChildAt(batch, <span class="hljs-number">0</span>);
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">this</span>.network.addChild(batch);
      <span class="hljs-keyword">this</span>.batches[type][color] = batch;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.batches[type][color];
  },

  _onEvent: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(event)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(e)</span> </span>{
      <span class="hljs-keyword">var</span> callback = <span class="hljs-keyword">this</span>.listeners[event] ? <span class="hljs-keyword">this</span>.listeners[event] : noop;
      e.offset = e.getLocalPosition(<span class="hljs-keyword">this</span>.stage);
      callback(e);
    }.bind(<span class="hljs-keyword">this</span>);
  }
};

<span class="hljs-keyword">if</span> (<span class="hljs-built_in">module</span> &amp;&amp; <span class="hljs-built_in">module</span>.exports) <span class="hljs-built_in">module</span>.exports = Grapher; <span class="hljs-comment">// export with module</span></div></div></div></div></body></html>